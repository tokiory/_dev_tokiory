---
title: Введение в Си
description: |
  Си — прекрасный язык программирования, который прошел сквозь огонь и воду.
  В данной статье мы разберем его основы и научимся с ним работать.
date: 2025-05-09
tags:
  - c
  - programming
---

<script>
	import Information from '$components/Content/ContentInformation.svelte'; import TronLinesBanner
	from '$mod/animation-entity/TronLinesBanner.svelte'; import MovingLine from
	'$mod/moving-line/components/MovingLine.svelte'; import CodeOutput from
	'$components/Content/ContentCodeOutput.svelte'; import CodeGallery from
	'$mod/code-gallery/Gallery.svelte'; import CodeSlide from '$mod/code-gallery/Slide.svelte'; import
	Tabulator from '$mod/tabulator/Tabulator.svelte'; import TabulatorTab from
	'$mod/tabulator/TabulatorTab.svelte'; import DoubleCol from
	'$components/Content/ContentDoubleCol.svelte'
</script>

**Си** — это язык программирования, который был разработан в начале 1970-х годов. Он стал основой для многих других языков, таких как C++, Java и Python. Си известен своей эффективностью и низким уровнем абстракции, что позволяет программистам работать ближе к аппаратному обеспечению.

<TronLinesBanner class="my-4" />

# Где сейчас используется Си?

Си по-прежнему широко используется в различных областях, включая:

- Разработка операционных систем (например, Linux)
- Встраиваемые системы (например, прошивки для микроконтроллеров)
- Игровая индустрия (например, Unreal Engine)
- Научные вычисления (например, библиотеки для численных методов)
- Системное программирование (например, драйверы устройств)
- Разработка компиляторов и интерпретаторов
- Сетевое программирование (например, реализация протоколов)
- Разработка баз данных (например, SQLite)
- Разработка графических интерфейсов (например, GTK+)

# Почему вообще нужно изучать эту древность?

На самом деле у каждого человека свои причины изучить Си. Лично для себя я выделил несколько причин:

- Си является основой для многих современных языков программирования, таких как C++, Java и Python. Изучение Си поможет мне лучше понимать как работают другие языки программирования;
- Си это низкоуровневый язык, который позволяет мне работать ближе к аппаратному обеспечению. Это полезно для понимания работы компьютера и операционных систем;

# Среда разработки

Для того чтобы писать на Си вам нужен любой редактор (практически все редакторы сходу поддерживают Си) и компилятор. Во многих системах компилятор для Си уже установлен. Проверить установлен ли компилятор можно с помощью следующей команды:

```bash
gcc -v
```

В случае если компилятор не установлен, мы можем установить его:

```bash
# MacOS
brew install gcc

# Ubuntu/Debian
sudo apt install build-essential

# Fedora/RHEL
sudo dnf groupinstall "Development Tools"
sudo dnf group install development-tools # Fedora 41+

# Arch
sudo pacman -S base-devel

# Windows
choco install mingw -y
```

# Структура программы

Программа на Си состоит из функций. Каждая программа должна содержать функцию `main`, которая является точкой входа в программу. Вот пример простой программы на Си:

```c play="https://www.programiz.com/online-compiler/2ZzexirKac3W2"
#include <stdio.h>
int main() {
    printf("Hello, World!\n");
    return 0;
}
```

<CodeOutput>

Hello, World!

</CodeOutput>

Давайте разберем данный кусок кода по частям:

<CodeGallery class="my-4">

<CodeSlide>

```c
// [!code focus]
#include <stdio.h>
int main() {
    printf("Hello, World!\n");
    return 0;
}
```

С помощью `#include <stdio.h>` мы подключаем стандартную библиотеку ввода-вывода, которая позволяет нам использовать функции для работы с вводом и выводом данных.

В данном случае мы используем функцию `printf`, которая выводит строку на экран.

</CodeSlide>

<CodeSlide>

```c
#include <stdio.h>
// [!code focus:4]
int main() {
    printf("Hello, World!\n");
    return 0;
}
```

В данном случае мы определяем функцию `main`, которая является точкой входа в программу. Каждая программа на Си должна содержать эту функцию.

</CodeSlide>

<CodeSlide>

```c
#include <stdio.h>
int main() {
    printf("Hello, World!\n");
    // [!code focus]
    return 0;
}
```

Функция `main` возвращает целое число, потому что мы определили её как `int main`.

Само число указывает на статус завершения программы.
Обычно мы возвращаем 0, что означает успешное завершение программы.

</CodeSlide>

</CodeGallery>

# Переменные и типы данных

Си сам по себе достаточно минималистичный и маленький язык программирования, у него есть необходимый минимум возможностей, но не более.

В Си есть несколько основных типов данных:

| Категория                                             | Описание                                                                                         | Примеры типов                                                                            |
| ----------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------- |
| **Целые числа** (Integers)                            | Целые числа, могут быть положительными или отрицательными.                                       | `char`, `int`, `short`, `long`, `long long`                                              |
| **Беззнаковые целые** (Unsigned integers)             | Целые числа, могут быть только положительными (или ноль).                                        | `unsigned char`, `unsigned int`, `unsigned short`, `unsigned long`, `unsigned long long` |
| **Числа с плавающей точкой** (Floating point numbers) | Вещественные числа (с дробной частью). Используются для точных вычислений.                       | `float`, `double`                                                                        |
| **Структуры** (Structures)                            | Пользовательские типы, объединяющие разные переменные под одним именем. Будут рассмотрены далее. | `struct MyStruct` (будет объяснено позже)                                                |
| **Пустой тип данных**                                 | Данный тип указывает на отсутствие каких-либо данных                                             | `void`                                                                                   |

<Information title="А где?" class="my-4">

В Си нет типа данных для строк, но строки можно представлять как массивы символов. Например, строка "Hello" может быть представлена как массив `char`.

</Information>
У каждого из этих типов данных есть своя размерность и диапазон значений, которые они могут хранить. Размеры типов данных могут варьироваться в зависимости от платформы и компилятора, но обычно они следующие:

<Tabulator class="my-4">
	<TabulatorTab title="Без модификатора" class="text-center">

| Тип      | Размер (байт) | Диапазон значений                   |
| -------- | ------------- | ----------------------------------- |
| `char`   | 1             | `-128` до `127`                     |
| `int`    | 4             | `-2,147,483,648` до `2,147,483,647` |
| `float`  | 4             | `±1.2E-38` до `±3.4E+38`            |
| `double` | 8             | `±2.3E-308` до `±1.7E+308`          |

</TabulatorTab>

<TabulatorTab title="Беззнаковое число" class="text-center">

| Тип                  | Размер (байт) | Диапазон значений                   |
| -------------------- | ------------- | ----------------------------------- |
| `unsigned char`      | 1             | `0` до `255`                        |
| `unsigned short`     | 2             | `0` до `65,535`                     |
| `unsigned int`       | 4             | `0` до `4,294,967,295`              |
| `unsigned long`      | 8             | `0` до `18,446,744,073,709,551,615` |
| `unsigned long long` | 8             | `0` до `18,446,744,073,709,551,615` |

</TabulatorTab>

<TabulatorTab title="Короткое число" class="text-center">

| Тип                   | Размер (байт) | Диапазон значений     |
| --------------------- | ------------- | --------------------- |
| `short` / `short int` | 2             | `-32,768` до `32,767` |
| `unsigned short`      | 2             | `0` до `65,535`       |

</TabulatorTab>

<TabulatorTab title="Длинное число" class="text-center">

| Тип                 | Размер (байт)        | Диапазон значений                                           |
| ------------------- | -------------------- | ----------------------------------------------------------- |
| `long` / `long int` | 8                    | `-9,223,372,036,854,775,808` до `9,223,372,036,854,775,807` |
| `unsigned long`     | 8                    | `0` до `18,446,744,073,709,551,615`                         |
| `long double`       | 16 (на Linux x86_64) | `±3.4E-4932` до `±1.1E+4932` (≈ 18–21 знаков)               |

</TabulatorTab>

<TabulatorTab title="Очень длинное число" class="text-center">

| Тип                           | Размер (байт) | Диапазон значений                                           |
| ----------------------------- | ------------- | ----------------------------------------------------------- |
| `long long` / `long long int` | 8             | `-9,223,372,036,854,775,808` до `9,223,372,036,854,775,807` |
| `unsigned long long`          | 8             | `0` до `18,446,744,073,709,551,615`                         |

</TabulatorTab>

</Tabulator>

Сам синтаксис объявления переменных в Си выглядит следующим образом:

```js
тип_данных имя_переменной [?= значение];
```

Вот пример объявления переменных:

```c play="https://www.programiz.com/online-compiler/04XsM0bRHwqDm"
int a = 5;
int b = 10;

printf("%d", a + b);
```

<CodeOutput>

15

</CodeOutput>


# Массивы и строки
В Си строки тесно связаны с массивами. Массивы же, в свою очередь, тесно связаны с типами данных и размерностями

На этом этапе мы научимся объявлять и инициализировать одномерные и двумерные массивы, эффективно итерироваться по ним, а также работать со строками и базовыми функциями из стандартной библиотеки `string.h`.

## Массивы

**Массив** — это базовая структура данных, предназначенная для хранения _фиксированного количества элементов одного типа_. Все элементы массива располагаются в памяти последовательно, что обеспечивает быстрый доступ по индексу. Массивы позволяют удобно представлять и обрабатывать наборы данных, таких как список чисел, координаты, таблицы и другие последовательности.

Вот пример инициализации и использования массивов:

```c play="https://www.programiz.com/online-compiler/0LhZJK58aSGsK"
#include <stdio.h>

int main() {
  // Объявление массива без явной инициализации элементов
  int foo[5];

  // Объявление массива с инициализацией
  double bar[3] = {1, 2, 3};

  // Объявление массива с автовычислением размера
  short far[] = {1, 2, 3, 4};
}
```

Для того чтобы изменить значение в ячейке массива или достать определенное значение из массива, мы должны использовать индекс. Индексы в Си начинаются с нуля, мы можем обратиться к определенной ячейке массива указав индекс в квадратных скобках:

```c play="https://www.programiz.com/online-compiler/4yAnv8p9gdc47"
int foo[5] = { 1, 2, 3, 4, 5 };

// Достаем элемент из ячейки с индексом 2
printf("%d\n", foo[2]); // 3

// Изменяем значение в ячейке массива с индексом 4
foo[4] = 20;

// Достаем элемент из ячейки с индексом 4
printf("%d\n", foo[4]); // 20
```

<CodeOutput>

3

20

</CodeOutput>

## Строки
Строки в Си не являются отдельным типом данных — они реализованы как массивы символов, завершаемые специальным нулевым символом `'\0'`. Этот символ служит маркером конца строки и позволяет стандартным функциям определять её длину, копировать, сравнивать и объединять строки.

```c
char str[] = "Hello"; // то же самое, что {'H', 'e', 'l', 'l', 'o', '\\0'}
```

Для того чтобы работать со строками в Си, нам предоставлена библиотека `string.h`:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char name[20] = "John";
    char greeting[50];

    // Копирование значения в строчный массив
    strcpy(greeting, "Hello, ");

    // Конкатенация строк
    strcat(greeting, name);

    printf("%s\n", greeting); // Выведет "Hello, John"
}
```

В `string.h` реализованы следующие функции:

- `strlen(char[])` — данная функция возвращает длину строки не учитывая `\\0`;
- `strcpy(dest char[], s char[])` — данная функция копирует строку `s` в строку `dest`;
- `strcat(dest char[], s char[])` — данная функция конкатенирует строки `dest` и `s`;
- `strcmp(s1 char[], s2 char[])` — сравнивает строки и возвращает `0`, если они идентичны;

## Операторы

В Си есть все необходимые операторы для работы с числовыми данными и не только, внизу перечислен каждый из них:

<Tabulator class="my-4">
<TabulatorTab title="Арифметические операторы">

| Оператор | Название           | Пример  | Описание                                     |
| -------- | ------------------ | ------- | -------------------------------------------- |
| `+`      | Сложение           | `a + b` | Складывает два значения                      |
| `-`      | Вычитание          | `a - b` | Вычитает второе значение из первого          |
| `*`      | Умножение          | `a * b` | Умножает два значения                        |
| `/`      | Деление            | `a / b` | Делит первое значение на второе              |
| `%`      | Остаток от деления | `a % b` | Возвращает остаток от целочисленного деления |

</TabulatorTab>

<TabulatorTab title="Операторы сравнения">

| Оператор | Название         | Пример   | Описание                    |
| -------- | ---------------- | -------- | --------------------------- |
| `==`     | Равно            | `a == b` | Проверяет равенство         |
| `!=`     | Не равно         | `a != b` | Проверяет неравенство       |
| `>`      | Больше           | `a > b`  | Истина, если `a` больше `b` |
| `<`      | Меньше           | `a < b`  | Истина, если `a` меньше `b` |
| `>=`     | Больше или равно | `a >= b` |                             |
| `<=`     | Меньше или равно | `a <= b` |                             |

</TabulatorTab>

<TabulatorTab title="Логические операторы">

| Оператор       | Название       | Пример             | Описание                                    |
| -------------- | -------------- | ------------------ | ------------------------------------------- |
| `&&`           | Логическое И   | `a && b`           | Истина, если оба выражения истинны          |
| `&#124;&#124;` | Логическое ИЛИ | `a &#124;&#124; b` | Истина, если хотя бы одно выражение истинно |
| `!`            | Логическое НЕ  | `!a`               | Инвертирует логическое значение             |

</TabulatorTab>
<TabulatorTab title="Побитовые операторы">

| Оператор | Название                  | Пример       | Описание                  |
| -------- | ------------------------- | ------------ | ------------------------- |
| `&`      | Побитовое И               | `a & b`      | Побитовое И двух значений |
| `&#124;` | Побитовое ИЛИ             | `a &#124; b` | Побитовое ИЛИ             |
| `^`      | Побитовое исключающее ИЛИ | `a ^ b`      | Побитовое XOR             |
| `~`      | Побитовое НЕ              | `~a`         | Инвертирует биты          |
| `<<`     | Сдвиг влево               | `a << 1`     | Сдвигает биты влево       |
| `>>`     | Сдвиг вправо              | `a >> 1`     | Сдвигает биты вправо      |

</TabulatorTab>

<TabulatorTab title="Операторы присваивания">

| Оператор  | Название              |    Пример     |    Эквивалент    |
| --------- | --------------------- | :-----------: | :--------------: |
| `=`       | Присваивание          |    `a = b`    |        -         |
| `+=`      | Прибавление и присв.  |   `a += b`    |   `a = a + b`    |
| `-=`      | Вычитание и присв.    |   `a -= b`    |   `a = a - b`    |
| `*=`      | Умножение и присв.    |   `a *= b`    |   `a = a * b`    |
| `/=`      | Деление и присв.      |   `a /= b`    |   `a = a / b`    |
| `%=`      | Остаток и присв.      |   `a %= b`    |   `a = a % b`    |
| `&=`      | Побитовое И и присв.  |   `a &= b`    |   `a = a & b`    |
| `&#124;=` | Побитовое ИЛИ и прис. | `a &#124;= b` | `a = a &#124; b` |
| `^=`      | Побит. XOR и присв.   |   `a ^= b`    |   `a = a ^ b`    |
| `<<=`     | Сдвиг влево и присв.  |   `a <<= 1`   |   `a = a << 1`   |
| `>>=`     | Сдвиг вправо и присв. |   `a >>= 1`   |   `a = a >> 1`   |

</TabulatorTab>

<TabulatorTab title="Другие операторы">

| Оператор | Название    | Пример                 | Описание                                      |
| -------- | ----------- | ---------------------- | --------------------------------------------- |
| `++`     | Инкремент   | `a++` или `++a`        | Увеличивает значение на 1                     |
| `--`     | Декремент   | `a--` или `--a`        | Уменьшает значение на 1                       |
| `?:`     | `a ? b : c` | `int foo = a ? b : c;` | Если `a` истина — возвращается `b`, иначе `c` |

</TabulatorTab>

</Tabulator>

## Размерность типа данных

В Си есть специальный оператор `sizeof`, который позволяет узнать размер типа данных в байтах.

В будущем нам все время нужно будет работать с их размерностью, этот оператор будет нам очень полезен:

```c play="https://www.programiz.com/online-compiler/8EGHO6zWTktwW"
int a = 5;
printf("%d", sizeof(a));
```

<CodeOutput>4</CodeOutput>

## Тайп-кастинг (приведение типов)

Си не обладает возможностью автоматического приведения типов, мы можем рассмотреть это на следующем примере:

```c play="https://www.programiz.com/online-compiler/7c28rUmhWgJ5X"
int a = 5;
int b = 2;
printf("%d", a / b);
```

<CodeOutput>2</CodeOutput>

Для того чтобы преобразовать типы на лету, мы можем указать нужный нам тип в круглых скобочках:

```c play="https://www.programiz.com/online-compiler/01U3qO3phRStd"
int a = 5;
int b = 2;
printf("%f", (float)a / b);
```

<CodeOutput>2.50000</CodeOutput>

У приведения типов, естественно, есть ограничения, среди которых:

- Приведение типов может привести к потере данных. Например, если вы преобразуете `double` в `int`, дробная часть будет отброшена.
- Приведение типов может вызвать переполнение или потерю значений. Например, преобразование большого `long` числа в `short` может привести к обрезанию данных.
- Приведение типов может привести к неопределенному поведению. Например, если вы преобразуете указатель (_о них мы поговорим позже_) на один тип в указатель на другой тип, это может привести к ошибкам доступа к памяти.
- Приведение типов может быть неэффективным. Например, преобразование `float` в `int` может потребовать дополнительных вычислений и замедлить выполнение программы.
- Приведение типов может привести к ошибкам компиляции. Например, если вы пытаетесь преобразовать указатель на функцию в указатель на другой тип функции, это приведет к ошибке компиляции.
- Приведение типов может нарушить выравнивание данных. Например, преобразование указателя на структуру с одним выравниванием в указатель на структуру с другим выравниванием может вызвать ошибки при доступе к данным.
- Приведение типов может затруднить отладку. Ошибки, связанные с некорректным приведением типов, часто сложно обнаружить и исправить, особенно в больших проектах.

# Управляющие конструкции

Си предоставляет разработчику полный набор управляющих конструкций, необходимых для построения логики выполнения программы.

К основным управляющим конструкциям в C относятся:

- **Условные операторы** — применяются для выбора направления выполнения программы в зависимости от заданного условия;
- **Циклы** — используются для повторного выполнения блока кода до тех пор, пока соблюдаются определённые условия;
- **Оператор выбора** — предоставляет способ обработки различных значений одного выражения и исполнения соответствующего кода для каждого случая, часто применяясь в структурах меню или при множественном ветвлении;
- **Операторы прерывания** — позволяют досрочно завершить выполнение цикла или пропустить текущую итерацию;
- **Оператор перехода** — позволяет осуществлять переход к произвольной метке в пределах функции;

# Условия

Условия в C реализованы с помощью операторов `if`, `else if` и `else`. Данные операторы позволяют выполнять определенные блоки кода в зависимости от истинности или ложности условия.

Истинными условиями в Си являются все значения, кроме нуля.

Обычно в других языках программирования существуют булев тип данных, который может принимать только два значения: `true` и `false`. В Си же все немного иначе, в нем нет булевого типа данных, но мы можем использовать целые числа для представления истинности или ложности.

```c play="https://www.programiz.com/online-compiler/5LhZ3sJz3S1Ay"
int a = 5;
if (a >= 5) {
  printf("Данный блок кода выполнится\n");
} else if (a < 5) {
  printf("Данный блок кода не выполнится\n");
} else {
  printf("Данный блок кода не выполнится\n");
}
```

## Булев тип данных и директивы препроцессора

Директива препроцессора `#define` используется для определения макросов — именованных констант или шаблонов кода, которые заменяются на этапе препроцессинга перед компиляцией.

Например, мы создадим макрос, который будет заменять все значения `tokiory` на "Даниил", вот как это будет выглядеть:

```c play="https://www.programiz.com/online-compiler/578wdpx4COygY"
#include <stdio.h>
#define tokiory "Даниил"

int main() {
  printf("Привет, меня зовут %s", tokiory);
  return 0;
}
```

<CodeOutput>Привет, меня зовут Даниил</CodeOutput>

Мы можем использовать `#define` для определения булевых значений:

```c play="https://www.programiz.com/online-compiler/4rlAMWiTj4A4w"
#include <stdio.h>
#define TRUE 1
#define FALSE 0

int main() {
  if (TRUE) {
    printf("Данный блок кода выполнится\n");
  } else {
    printf("Данный блок кода не выполнится\n");
  }

  return 0;
}
```

<CodeOutput>Данный блок кода выполнится</CodeOutput>

# Циклы

В Си реализованы несколько типов циклов, которые можно использовать с помощью ключевых слов `while`, `do ... while` и `for`.

## Цикл с предусловием

Начнем с простого, `while` это цикл, который будет выполнять код до тех пор, пока условие внутри скобочек истинно:

```c play="https://www.programiz.com/online-compiler/678wdMeFYOOkG"
int i = 0;
while (i < 5) {
  printf("Текущий индекс: %d", i);
  i++;
}
```

<CodeOutput>
  Текущий индекс: 0

Текущий индекс: 1

Текущий индекс: 2

Текущий индекс: 3

Текущий индекс: 4

</CodeOutput>

Оператор `++` в сниппете выше, увеличивает значение `i` на `1`. Это необходимо для того, чтобы мы не попали в вечный цикл.

Если же мы специально хотим попасть в вечный цикл, то это можно сделать просто пробросив в скобки условие, которое всегда будет истинно:

```c
int i = 0;
while (1) {
  printf("Текущий индекс: %d", i);
  i++;
}
```

<CodeOutput>
  Текущий индекс: 0

Текущий индекс: 1

Текущий индекс: 2

Текущий индекс: 3

Текущий индекс: 4

Текущий индекс: 5

Текущий индекс: 6

Текущий индекс: 7

... (до бесконечности или пока i не переполнится)

</CodeOutput>

## Цикл с постусловием

Цикл `do while` занимается примерно тем же, что и `while`. Их различие состоит только в том, что `do while` всегда выполняется хотя бы один раз.
Использование данного цикла распространено в геймдеве, где определенному действию нужна хотя бы одна итерация:

```c play="https://www.programiz.com/online-compiler/765g7WWE7oFN5"
int i = 0;

// Условие уже не истинно со старта, но блок кода все равно выполнится один раз
do {
  printf("Текущий i: %d", i);
} while (i < 0);
```

<CodeOutput>Текущий i: 0</CodeOutput>

## Цикл с параметрами

Цикл `for` является самым подробным циклом, он позволяет объявить и инициализировать переменную, указать условие в рамках которого цикл будет работать и указать что и как будет изменяться после каждой итерации цикла. Рассмотрим пример:

```c play="https://www.programiz.com/online-compiler/6Q196SeqAjXQd"
for (int i = 0; i < 5; i++) {
  printf("Текущая итерация: %d\n", i + 1);
}
```

<CodeOutput>
  Текущая итерация: 1

Текущая итерация: 2

Текущая итерация: 3

Текущая итерация: 4

Текущая итерация: 5

</CodeOutput>

- `int i = 0` является **инициализацией**, в данном блоке мы можем объявить переменную с любым названием для использования в цикле. После того как цикл закончится, переменная перестанет существовать;
- `i < 5` является **условием цикла**, по которому будет работать цикл, пока данное условие истинно – цикл будет продолжаться;
- `i++` является **выражением итерации**, данное выражение будет выполняться после каждой итерации;

## Операторы прерывания

В любом из вышеперечисленных циклов можно использовать **операторы прерывания**. Данные операторы нужны для того чтобы прерывать выполнение итераций и в зависимости от указанного оператора продолжать цикл со следующей итерации или выходить из цикла.

Всего в Си два ключевых слова для прерывания циклов:

- `break` — ключевое слово, которое используется для того чтобы немедленно завершить цикл;
- `continue` — ключевое слово, которое используется для того чтобы пропустить текущую итерацию;

```c play="https://www.programiz.com/online-compiler/5FW5c61Hn9JYC"
for (int i = 0; i < 20; i++) {

  // Пропускаем итерации, когда i — нечетное число
  if (i % 2 != 0) {
    continue;
  }

  // Выходим из цикла, когда i больше, либо равно 10
  if (i >= 10) {
    break;
  }

  printf("Текущая итерация: %d\n", i);
}
```

<CodeOutput>
Текущая итерация: 0

Текущая итерация: 2

Текущая итерация: 4

Текущая итерация: 6

Текущая итерация: 8

</CodeOutput>

## Оператор выбора

Конструкцией выбора в Си является блок кода, где используется ключевое слово `switch`. Данный оператор позволяет выбрать один из блоков кода в зависимости от выполнения условия:

```c play="https://www.programiz.com/online-compiler/5Wvx2GBVT3cBw"
int a = 2;

switch (a) {
  case 1:
    printf("В данном случае a равно единице");
    break;
  case 2:
    printf("В данном случае a равно двум");
    break;
  case 3:
    printf("В данном случае a равно трём");
    break;
  default:
    printf("В данном случае a равно чему-то другому");
}
```

<CodeOutput>В данном случае a равно двум</CodeOutput>

- `switch` — это ключевое слово, которое указывает на то, что мы сейчас будем выбирать один из вариантов выполнения кода.
- `case` — ключевое слово, которое говорит нам о том, чему должна быть равна переменная или выражение в скобках возле `switch` для того чтобы выполнился блок `case`;
- `default` — это блок кода, который выполнится, если ни одно из условий из `case` не было удовлетворено;

Примечательно, что тут используется оператор прерывания `break`, который мы рассматривали до этого.

Если мы не укажем его, то при удовлетворении условий одного из `case`, все последующие блоки `case` тоже будут выполнены:

```c play="https://www.programiz.com/online-compiler/33arfB6IkJcJp"
int a = 2;

switch (a) {
  case 1:
    printf("В данном случае a равно единице\n");
  // [!code highlight:6]
  case 2:
    printf("В данном случае a равно двум\n");
  case 3:
    printf("В данном случае a равно трём\n");
  default:
    printf("В данном случае a равно чему-то другому\n");
}
```

<CodeOutput>
В данном случае a равно двум

В данном случае a равно трём

В данном случае a равно чему-то другому

</CodeOutput>

# Оператор перехода

**Оператор перехода** — это низкоуровневая управляющая конструкция, позволяющая передавать управление не по логике программы, а непосредственно в заданное место кода.

<Information title="Плохая практика">

Использовать оператор перехода стоит только в очень крайних случаях, когда кровь из носа как нужно пропустить определенный блок кода.

**Но почему мне не стоит его использовать?** <br/>
Использование данного оператора сильно усложнит вам и вашим коллегам жизнь при отладке кода, да и в целом оно сильно усложняет логику.

</Information>

Оператор перехода в Си реализован через ключевое слово `goto` и метки:

```c play="https://www.programiz.com/online-compiler/6HdUWt9gQL6CY"
int a = 0;

printf("Начали вычисление\n");
goto skip;

if (a < 0) {
  printf("a меньше нуля\n");
} else if (a == 0) {
  printf("a равно нулю\n");
} else {
  printf("a больше нуля\n");
}

skip:
printf("Закончили вычисление\n");
```

<CodeOutput>
Начали вычисление

Закончили вычисление

</CodeOutput>

# Функции

**Функции** — это базовые строительные блоки программы, позволяющие структурировать код, повысить читаемость, переиспользуемость и модульность.
Функции в Си могут принимать аргументы и отдавать определенные значения.

<Information title="Объекты первого класса">

В Си функции не являются объектами первого класса, то есть вы не можете передавать функции в другие функции через аргументы, но об этом мы поговорим позже, когда доберемся до указателей.

</Information>

Функции в Си объявляются с помощью следующего синтаксиса:

```c
[возвращаемый тип данных] [название функции]([?аргументы]) {
  [код]
}
```

Давайте напишем простую функцию, заачей которой будет просто выводить слово `"Привет!"`, данная функция не будет принимать никаких входных данных и ничего не будет отдавать:

```c play="https://www.programiz.com/online-compiler/0uy0TzAvCHMzK"
#include <stdio.h>

// [!code highlight:3]
void say_hello() {
  printf("Привет!\n");
}
```

Для того чтобы вызвать нашу функцию, мы должны указать её имя и поставить круглые скобочки.

В круглые скобки можно будет передавать _аргументы согласно параметрам_, об этом мы поговорим чуть-чуть позже. Пока что мы можем просто указать пустые скобки (то есть ничего в них не передавать), для того чтобы просто вызвать функцию без аргументов:

```c play="https://www.programiz.com/online-compiler/0uy0TzAvCHMzK"
#include <stdio.h>

void say_hello() {
  printf("Привет!\n");
}

int main() {
  // [!code highlight:3]
  say_hello();
  say_hello();
  say_hello();
}
```

<CodeOutput>

Привет!

Привет!

Привет!

</CodeOutput>

## Аргументы и возвращаемые значения

Функции в Си могут получать аргументы и отдавать возвращаемые значения. При объявлении функции мы указываем тип, который наша функция должна вернуть, данный тип называется **типом возвращаемого значения**.

Например, функция `main`, которую мы уже не один раз писали должна возвращать число.
Если мы явно не укажем число возвращаемое число с помощью ключевого слова `return`, то функция будет возвращать нулевое значение (в данном случае — 0):

```c play="https://www.programiz.com/online-compiler/5qb2exYwC57WD"
#include <stdio.h>
int get_number() {}

int main() {
  printf("%d", get_number());
}
```

<CodeOutput>0</CodeOutput>

**Параметры функции** — это переменные, которые объявляются в определении функции и служат для получения данных, с которыми функция будет работать. Они указываются в круглых скобках после имени функции и позволяют сделать функцию универсальной, чтобы она могла выполнять действия с разными входными данными.

Давайте создадим простую функцию, которая будет складывать три числа:

```c play="https://www.programiz.com/online-compiler/7sF6CPvSiIqCT"
#include <stdio.h>

int sum3(int a, int b, int c) {
  return a + b + c;
}

int main() {
  printf("%d\n", sum3(12, 24, 36));
}
```

<CodeOutput>72</CodeOutput>

В данном случае числа `12, 24, 36` — являются аргументами функции. Тип аргументов, которые мы передаем в функцию всегда должен соответствовать типам указанных параметров при объявлении функции.

## Прототипы функций

**Прототип функции** — это объявление функции, которое указывает её имя, тип возвращаемого значения и типы параметров, позволяя компилятору заранее проверить корректность вызовов до фактической реализации функции.

```c
void say_hello();
```

В Си мы не можем использовать функцию до её объявления, потому что компилятор не будет знать какие именно типы данных функция принимает в параметрах и какой тип данных функция будет возвращать. Следующий пример кода работать не будет:

```c
int main() {
  say_hello();
}

void say_hello() {
  printf("Привет!\n");
}
```

<CodeOutput>

error: implicit declaration of function 'say_hello'

[-Wimplicit-function-declaration]

    4 |   say_hello();

</CodeOutput>

В случае если нам нужно использовать функцию до её объявления мы можем использовать **прототип функции**. Его можно указать вверху файла или в отдельном `.h` файле.

Второй способ является предпочтительным, так как помогает отделить реализацию функции от её интерфейса:

<DoubleCol>

```c play="https://www.programiz.com/online-compiler/7oVuOUareE3sS" filename=main.c
#include <stdio.h>
#include <say_hello.h>

int main() {
  // [!code highlight]
  say_hello();
}

// Реализация функции
// [!code highlight:3]
void say_hello() {
  printf("Привет!\n");
}
```

```c
// Прототип функции
// [!code highlight]
void say_hello();
```

</DoubleCol>

<CodeOutput>

Привет!

</CodeOutput>

## Область видимости

**Блочная область видимости** — это область действия переменной, ограниченная телом блока, заключённого в фигурные скобки `{}`. Переменные с такой областью видимы и доступны только внутри этого блока и уничтожаются при выходе из него.

По умолчанию все переменные ограничены блочной областью видимости.

```c play="https://www.programiz.com/online-compiler/4sF6CLiAAIvOe"
#include <stdio.h>

int main() {
  int a = 10;

  {
    int b = 20;
    printf("b=%d\n", b);
  }
  // Здесь b более недоступна

  printf("a=%d\n", a);
}
// Здесь a более недоступна
```

<CodeOutput>

b=20

a=10

</CodeOutput>

**Функциональная область видимости** — это область действия параметров функции, которые видимы и доступны только внутри тела этой функции.

```c
#include <stdio.h>

void foo() {
  int a = 0;
}
// Здесь a более не доступна
```

**Глобальная область видимости** — это область действия переменных, объявленных вне всех функций и блоков. Такие переменные доступны во всём исходном файле, а при использовании ключевого слова `extern` — и в других файлах проекта.

```c filename=main.c
// Доступна только в main.c
int a = 0;

// Доступна в рамках всей программы
extern int b = 2;
```

### Статические переменные

Если нам нужно хранить какое-либо состояние между вызовами функции, то мы можем сделать это двумя способами. Первый способ заключается в объявлении переменной в глобальной области видимости:

```c play="https://www.programiz.com/online-compiler/82EtXzPPZfxUX"
#include <stdio.h>
int state = 0;

void inc() {
  state++;
}

int main() {
  inc();
  inc();

  printf("%d\n", state);
}
```

<CodeOutput>

2

</CodeOutput>

Второй способ заключается в использовании статической переменной, она объявляется с помощью ключевого слова `static`.

Данное ключевое слово позволяет нам назначить переменной статический адрес. При вызове функции адрес переменной не будет меняться, сама же переменная не будет реинициализирована, в случае если инициализация уже произошла:

```c play="https://www.programiz.com/online-compiler/60nvb0EjTUTuf"
#include <stdio.h>
int inc() {
  static int state = 0;
  state++;
  return state;
}

int main() {
  inc();
  int s = inc();

  printf("%d\n", s);
}
```

<CodeOutput>

2

</CodeOutput>

# Указатели
**Указатели** — это переменные, которые хранят адрес другой переменной, то есть ссылку на её расположение в памяти. Вместо того чтобы работать с данными напрямую, указатели позволяют работать с их адресами, что открывает огромные возможности для более эффективной работы с памятью и гибкости программирования.

Для начала давайте разберемся с адресами. У каждой переменной, которую вы объявили есть адрес, мы можем получить его с помощью оператора `&`:

```c play="https://www.programiz.com/online-compiler/0G4dUTs30NRZZ"
int foo = 12;
printf("Value is: %d\nAddress is: %d\n", foo, &foo);
```

<CodeOutput>

Value is: 12

Address is: 2112977036

</CodeOutput>

Для того чтобы объявить указатель, нужно указать тип данных, на который он будет ссылаться, а затем использовать символ `*`:

```c
int *ptr;     // Указатель на целое число
double *dptr; // Указатель на число с плавающей запятой
char *cptr;   // Указатель на символ
```

Мы можем инициализировать указатели с помощью специального значения `NULL` (будет означать что указатель никуда не ссылается) или с помощью оператора ссылки:

```c
int a = 5;
int *a_ptr = &a;   // Теперь a_ptr ссылается на a
int *a_ptr = NULL; // Теперь a_ptr никуда не ссылается
```





<!--
Этап 6: Указатели
Цель: понять механизмы управления памятью.

🔹 Темы:
Объявление и разыменование указателей

& и *, передача по указателю

Указатели и массивы

Указатели на строки

const указатели

✅ Практика:
Функция, меняющая местами два значения через указатели

Поиск символа в строке

Реализация функций strlen, strcpy вручную через указатели

Этап 7: Динамическая память
Цель: научиться выделять и освобождать память вручную.

🔹 Темы:
malloc, calloc, realloc, free

Утечки памяти и их отладка (valgrind)

Проверка выделения памяти

✅ Практика:
Динамический массив

Программа для хранения списка студентов с произвольной длиной

Построчное считывание из stdin

Этап 8: Структуры и перечисления
Цель: научиться работать с пользовательскими типами.

🔹 Темы:
struct и вложенные структуры

Указатели на структуры

enum

Операции с полями структур

✅ Практика:
Реализация структуры "Дата"

Телефонная книга

Стек на структурах

Этап 9: Работа с файлами
Цель: уметь сохранять и загружать данные.

🔹 Темы:
FILE*, fopen, fread, fwrite, fprintf, fscanf, fclose

Различие между текстовыми и бинарными файлами

Проверка ошибок открытия/чтения

✅ Практика:
Запись и чтение массива структур в файл

Анализ содержимого текстового файла

Сериализация пользовательских данных

Этап 10: Углублённые темы и системное программирование
Цель: подготовка к написанию низкоуровневого ПО.

🔹 Темы:
Указатели на функции

Массив указателей на функции (таблицы диспетчеризации)

Макросы и #define

typedef

Работа с аргументами командной строки (argc, argv)

Основы работы с POSIX API (на уровне знакомства)

✅ Практика:
Простейшая реализация CLI

Мини-компилятор арифметических выражений

Простая программа для работы с файловой системой Linux

Этап 11: Инструменты, тестирование и отладка
Цель: выстроить грамотный процесс разработки.

🔹 Темы:
Makefile

Статический анализ кода (cppcheck, clang-tidy)

Модульное тестирование (например, с cmocka)

Отладка в gdb, valgrind

✅ Практика:
Создать собственный Makefile для мини-проекта

Провести юнит-тестирование функции сортировки

Найти и устранить утечку памяти

-->
