---
title: 'Введение в Zig'
description: 'В данной статье мы кратко рассмотрим основы языка Zig'
date: 2025-06-11
tags:
  - zig
  - intro
---

<script>
	import ZeroOneLine from '$components/Content/ContentZeroOneLine.svelte'; import CodeOutput from
	'$components/Content/ContentCodeOutput.svelte'; import Tabulator from
	'$mod/tabulator/Tabulator.svelte'; import TabulatorTab from '$mod/tabulator/TabulatorTab.svelte';
	import Information from '$components/Content/ContentInformation.svelte';
	import MovingZ from '$mod/animation-entity/MovingZ.svelte';
</script>

После того как я немного потинкерил Си, мне стало интересно есть ли какой-то современный низкоуровневый язык программирования, который бы фиксил
часть недостатков экосистемы Си (система сборки, система пакетов, система тестирования и маленькая стандартная библиотека).

Среди популярных низкоуровневых языков программирования до сих пор лидирует C, однако, появились и новые, среди которых
[C3](https://c3-lang.org/), [Zig](https://ziglang.org/), [Rust](https://www.rust-lang.org/) и [Odin](https://odin-lang.org/).

<MovingZ class="my-4" />

# Общий обзор

**Zig** — это язык общего назначения со встроенным тулкитом, который позволяет разрабатывать гибкое и стрессоустойчивое ПО.
Когда у языка из коробки поставляется стандартная библиотека для тестирования, большая стандартная библиотека и удобная система аллокации памяти, мой глаз не может не радоваться.

Код на Zig выглядит достаточно выразительным, простым и лаконичным:

```zig
const std = @import("std");

pub fn main() void {
  const hello = "hello"
  const world = "world"
  std.debug.print("{} {}\n", .{ foo, bar });
}
```

<CodeOutput>

hello world

</CodeOutput>

# Комментарии

В Zig есть три типа комментариев:

1. Обычные комментарии
2. Док-комментарии
3. Верхнеуровневые комментарии

## Обычные комментарии

Обычные комментарии в Zig начинаются с `//`, прямо как в Си, единственным отличием комментариев в Zig является то, что в Zig не сущетсвует многострочных комментариев:

```zig
// Это комментарий
// Это тоже комментарий
```

## Док-комментарии

Док-комментарии начинаются с `///` и используются для документирования кода:

```zig
/// Функция для сложения двух чисел
pub fn add(a: i32, b: i32) i32 {
  return a + b;
}
```

> Примечательно, что если такие комментарии будут использоваться не для документирования переменных, функций или структур, то такие комментарии будут считаться невалидными и будут вызывать ошибку компиляции.
>
> Следующий код вызовет ошибку компиляции:
>
> ```zig
> /// Функция для вычитания двух чисел
> // Данный комментарий является обычным
> pub fn sub(a: i32, b: i32) i32 {
>   return a - b;
> }
> ```

## Верхнеуровневые комментарии

Верхнеуровневые комментарии начинаются с `//!` и используются для документирования модулей:

```zig
//! Модуль для работы с числами

/// Функция для сложения двух чисел
pub fn add(a: i32, b: i32) i32 {
  return a + b;
}
```

Верхнеуровневые комментарии, которые начинаются не в начале файла будут игнорироваться компилятором.

# Типизация

У Zig достаточно выразительная и мощная система типизации, которая позволяет определять типы переменных, функций и структур.

<Tabulator class="mt-4">

<TabulatorTab title="Целочисленные типы">

Вот обновленная таблица на русском языке с добавлением предоставленных значений:

| Тип     | Эквивалент в C        | Описание                                   |
| ------- | --------------------- | ------------------------------------------ |
| `i8`    | `int8_t`              | Знаковый 8-битный целый тип                |
| `u8`    | `uint8_t`             | Беззнаковый 8-битный целый тип             |
| `i16`   | `int16_t`             | Знаковый 16-битный целый тип               |
| `u16`   | `uint16_t`            | Беззнаковый 16-битный целый тип            |
| `i32`   | `int32_t`             | Знаковый 32-битный целый тип               |
| `u32`   | `uint32_t`            | Беззнаковый 32-битный целый тип            |
| `i64`   | `int64_t`             | Знаковый 64-битный целый тип               |
| `u64`   | `uint64_t`            | Беззнаковый 64-битный целый тип            |
| `i128`  | `__int128`            | Знаковый 128-битный целый тип              |
| `u128`  | `unsigned __int128`   | Беззнаковый 128-битный целый тип           |
| `isize` | `intptr_t`            | Знаковый целый тип размером с указатель    |
| `usize` | `uintptr_t`, `size_t` | Беззнаковый целый тип размером с указатель |

</TabulatorTab>

<TabulatorTab title="Числа с плавающей точкой">

| Тип    | Эквивалент в C | Описание                                                                                  |
| ------ | -------------- | ----------------------------------------------------------------------------------------- |
| `f16`  | `_Float16`     | 16-битный тип с плавающей точкой (10-битная мантисса), IEEE-754-2008 binary16             |
| `f32`  | `float`        | 32-битный тип с плавающей точкой (23-битная мантисса), IEEE-754-2008 binary32             |
| `f64`  | `double`       | 64-битный тип с плавающей точкой (52-битная мантисса), IEEE-754-2008 binary64             |
| `f80`  | `long double`  | 80-битный тип с плавающей точкой (64-битная мантисса), IEEE-754-2008 расширенная точность |
| `f128` | `_Float128`    | 128-битный тип с плавающей точкой (112-битная мантисса), IEEE-754-2008 binary128          |

</TabulatorTab>

<TabulatorTab title="Логические типы">

| Тип    | Эквивалент в C | Описание                                                     |
| ------ | -------------- | ------------------------------------------------------------ |
| `bool` | `bool`         | 8-битный тип логического значения, может быть true или false |

</TabulatorTab>

<TabulatorTab title="Другие типы данных">

| Тип              | Эквивалент в C | Описание                                                                                      |
| ---------------- | -------------- | --------------------------------------------------------------------------------------------- |
| `anyopaque`      | `void`         | Используется для указателей с удалённым типом                                                 |
| `void`           | Не существует  | Всегда имеет значение void                                                                    |
| `noreturn`       | Не существует  | Тип для break, continue, return, unreachable и while (true)                                   |
| `type`           | Не существует  | Тип для типов                                                                                 |
| `anyerror`       | Не существует  | Код ошибки                                                                                    |
| `comptime_int`   | Не существует  | Разрешён только для значений, известных на этапе компиляции. Тип целочисленных литералов      |
| `comptime_float` | Не существует  | Разрешён только для значений, известных на этапе компиляции. Тип литералов с плавающей точкой |
| `?T`             | Нет эквивалента (или `T*` с NULL) | Опциональный тип, может быть `null`                 |
| `T!E`            | Нет эквивалента             | Тип результата с возможной ошибкой типа E                 |
| `async`          | Нет эквивалента             | Тип для асинхронных функций                               |
| `anyframe`       | Нет эквивалента             | Тип для работы с асинхронными фреймами                    |

</TabulatorTab>

<TabulatorTab title="Составные типы">

| Тип              | Эквивалент в C              | Описание                                                  |
|------------------|-----------------------------|-----------------------------------------------------------|
| `struct`         | `struct`                    | Группировка данных с именованными полями                  |
| `union`          | `union`                     | Объединение, где активно только одно поле                 |
| `union(enum)`    | `union` с `enum`            | Теговое объединение с явным перечислением активного поля  |
| `enum`           | `enum`                      | Перечисление с именованными целочисленными значениями     |
| `error`          | Нет эквивалента             | Тип для определения пользовательских ошибок               |

</TabulatorTab>

<TabulatorTab title="Массивы и срезы">

| Тип              | Эквивалент в C              | Описание                                                  |
|------------------|-----------------------------|-----------------------------------------------------------|
| `[N]T`           | `T[N]`                      | Массив фиксированной длины N элементов типа T             |
| `[]T`            | `T*` (с длиной отдельно)    | Срез, динамический массив с указателем и длиной           |
| `[*:0]T`         | `T*` (null-терминированный) | Указатель на null-терминированный массив типа T           |
| `[*]T`           | `T*`                        | Указатель на массив неизвестной длины типа T              |

</TabulatorTab>

<TabulatorTab title="Указатели">

| Тип              | Эквивалент в C              | Описание                                                  |
|------------------|-----------------------------|-----------------------------------------------------------|
| `*T`             | `T*`                        | Указатель на одно значение типа T                         |
| `[*]T`           | `T*`                        | Указатель на массив неизвестной длины типа T              |
| `[*:0]T`         | `T*` (null-терминированный) | Указатель на null-терминированный массив типа T           |
| `?*T`            | `T*` (с проверкой на NULL)  | Опциональный указатель, может быть `null`                 |
| `c_char`         | `char*`                     | Указатель, совместимый с C-строками                       |

</TabulatorTab>

</Tabulator>

# Переменные
Мутабельные переменные в Zig объявляются с помощью ключевого слова `var`, примечательно, что после указания названия переменной мы всегда должны указать тип переменной:

```zig
var x: i32 = 42;
var y: f64 = 3.14;
var z: bool = true;

var hi: ?[]const u8 = "Hello, Zig!";
hi = null;
```

Константные переменные объявляются с помощью ключевого слова `const`, по умолчанию если ваша переменная не изменяется, то Zig выдаст ошибку компиляции при использовании `var` вместо `const` с такой переменной. У констант можно не указывать тип данных, так как Zig может их вывести самостоятельно:

```zig
const x = 42;
const y: f64 = 3.14;
const z: bool = true;
```

<Information title="Указатели и константы">

Если у нас указатель, который инициализирован в константе, то мы можем менять значения по адресу,
который хранится в указателе.

Если мы хотим, чтобы указатель был константным, то мы можем использовать `const` для указателя:

```zig
const ptr: *const i32 = &x;
```

</Information>

Значения при инициализации переменных необязательно указывать на той же строке, что и объявление переменной. Это бывает полезно, при работе с мультистроковыми данными (напр. строками):

```zig
const std = @import("std");

pub fn main() void {
  const hello_world_in_c =
      \\#include <stdio.h>
      \\
      \\int main(int argc, char **argv) {
      \\    printf("hello world\n");
      \\    return 0;
      \\}
  ;

  std.debug.print("{s}\n", .{hello_world_in_c});
}
```

## Неинициализированные переменные
По умолчанию мы не можем объявить какую-либо переменную без инициализации. Если мы хотим, чтобы переменная была неинициализированной, то мы можем использовать ключевое слово `undefined`:

```zig
var x: i32 = undefined;
var y: f64 = undefined;
var z: bool = undefined;
```

# Массивы

Массивы в Zig являются фундаментальной структурой данных, которая хранит значения одного типа в непрерывной последовательности.

Мы уже использовали массивы данных выше, в примере с `hi`, тогда мы использовали массив из `u8`, сам тип данных `u8` нужен для целочисленных неотрицательных 8-битных чисел.

Внутри данных чисел мы можем хранить репрезентацию символов в виде числовых значений. Именно поэтому мы использовали тип `[]const u8` для того чтобы хранить строки, по сути строку `"Hello World!"` можно расписать следующим образом:

```zig
var text = [_]const u8{ 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!' };
```
